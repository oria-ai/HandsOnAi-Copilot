Instructions for Developer: Refactoring the Demo to the Full SystemYour task is to convert the existing "HandsOnAi" demo project into the full, database-driven application specified in the architectural documents. Follow these phases in order.Phase 1: Backend & Database OverhaulYour first priority is to build a robust backend. Do not modify the frontend yet.Update the Database Schema:Open the file /server/prisma/schema.prisma.Delete all of its contents.Copy the entire, final schema from 4. Detailed_Technical_Design.md and paste it into the schema.prisma file. This schema includes all tables for content, users, progress, and the new UserEvent table for analytics.Re-create the Local Database:In your terminal, navigate to the /server directory.Delete the old database file: rm prisma/dev.db.Run the Prisma migration command to create the new database structure: npx prisma migrate dev --name "implement-full-schema".Rewrite the Backend Server (/server/src/index.ts):Refactor the server to be modular. Create separate files for your routes, controllers, and services.Implement the user authentication endpoints (/api/v1/auth/login, /api/v1/auth/register). These should handle password checking (for now, plaintext is fine) and issue a JWT upon successful login.Implement the core content endpoint: GET /api/v1/steps/{stepId}. This endpoint must be protected by JWT authentication. It needs to contain the full logic for resolving content variants based on the authenticated user's profile attributes.Implement the analytics endpoint: POST /api/v1/events. This endpoint will receive event data from the frontend and write it to the UserEvents table.Update the Seed Script:Modify /server/scripts/seed.ts to populate all the new tables with realistic test data. Create at least one full module with several steps, screens, and components, including some variants.Run npm run seed from the /server directory to populate your new database.Phase 2: Frontend RefactoringNow, connect the frontend to your new, powerful backend.Create an API Client:In /src/lib/, create a file api.ts.Use a library like axios to create a client that automatically attaches the user's JWT (stored in local storage after login) to the Authorization header of every API request.Make the UI Dynamic:Go to ModuleView.tsx and all related task components (ClickTutor.tsx, etc.).Remove all hardcoded content. The frontend should not contain any lesson data, questions, or image paths.Use a custom hook (useModuleData.ts) to fetch the data for the current step from your backend's GET /api/v1/steps/{stepId} endpoint.The UI must be refactored to render itself based entirely on the JSON structure returned by the API. Use map functions to iterate over the screens and components arrays and render the appropriate React components.Implement Analytics Event Tracking:Instrument the frontend to send events to the POST /api/v1/events endpoint for all key user interactions:Video: onPlay, onPause, onSeeked, onEnded.Navigation: TASK_SKIP, CHAPTER_CLICK.Engagement: SCREEN_VIEW_DURATION (track how long a screen is visible).Phase 3: Administrative ViewsFinally, build the interfaces for the Manager and Author personas.Create Protected Routes:In App.tsx, create new routes for /manager and /authoring.These routes should be wrapped in a component that checks the user's role from their JWT and redirects them if they are not authorized.Build the Manager Dashboard:Create the UI as specified in the design documents.Create new backend endpoints that query the UserProgress and UserEvents tables to provide aggregated data for the dashboard.Build the Authoring View:Create a new UI that allows an authenticated AUTHOR to perform CRUD operations on modules, steps, screens, and components.The most important feature is the variant editor. The UI must allow the author to select a user attribute (e.g., "Role") and a value (e.g., "Marketing") and then edit the content for that specific variant.Implement the corresponding POST, PUT, and DELETE endpoints in the backend to handle these content modifications.